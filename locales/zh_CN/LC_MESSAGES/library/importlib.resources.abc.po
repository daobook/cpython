# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-10-12 09:44+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.10.3\n"

#: ../../library/importlib.resources.abc.rst:2
msgid ":mod:`importlib.resources.abc` -- Abstract base classes for resources"
msgstr ""

#: ../../library/importlib.resources.abc.rst:7
msgid "**Source code:** :source:`Lib/importlib/resources/abc.py`"
msgstr ""

#: ../../library/importlib.resources.abc.rst:15
msgid "*Superseded by TraversableResources*"
msgstr ""

#: ../../library/importlib.resources.abc.rst:17
msgid "An :term:`abstract base class` to provide the ability to read *resources*."
msgstr ""

#: ../../library/importlib.resources.abc.rst:20
msgid ""
"From the perspective of this ABC, a *resource* is a binary artifact that "
"is shipped within a package. Typically this is something like a data file"
" that lives next to the ``__init__.py`` file of the package. The purpose "
"of this class is to help abstract out the accessing of such data files so"
" that it does not matter if the package and its data file(s) are stored "
"in a e.g. zip file versus on the file system."
msgstr ""

#: ../../library/importlib.resources.abc.rst:28
msgid ""
"For any of methods of this class, a *resource* argument is expected to be"
" a :term:`path-like object` which represents conceptually just a file "
"name. This means that no subdirectory paths should be included in the "
"*resource* argument. This is because the location of the package the "
"reader is for, acts as the \"directory\". Hence the metaphor for "
"directories and file names is packages and resources, respectively. This "
"is also why instances of this class are expected to directly correlate to"
" a specific package (instead of potentially representing multiple "
"packages or a module)."
msgstr ""

#: ../../library/importlib.resources.abc.rst:39
msgid ""
"Loaders that wish to support resource reading are expected to provide a "
"method called ``get_resource_reader(fullname)`` which returns an object "
"implementing this ABC's interface. If the module specified by fullname is"
" not a package, this method should return :const:`None`. An object "
"compatible with this ABC should only be returned when the specified "
"module is a package."
msgstr ""

#: ../../library/importlib.resources.abc.rst:50
#: ../../library/importlib.resources.abc.rst:157
msgid "Use :class:`importlib.resources.abc.TraversableResources` instead."
msgstr ""

#: ../../library/importlib.resources.abc.rst:53
msgid ""
"Returns an opened, :term:`file-like object` for binary reading of the "
"*resource*."
msgstr ""

#: ../../library/importlib.resources.abc.rst:56
msgid "If the resource cannot be found, :exc:`FileNotFoundError` is raised."
msgstr ""

#: ../../library/importlib.resources.abc.rst:61
msgid "Returns the file system path to the *resource*."
msgstr ""

#: ../../library/importlib.resources.abc.rst:63
msgid ""
"If the resource does not concretely exist on the file system, raise "
":exc:`FileNotFoundError`."
msgstr ""

#: ../../library/importlib.resources.abc.rst:68
msgid ""
"Returns ``True`` if the named *name* is considered a resource. "
":exc:`FileNotFoundError` is raised if *name* does not exist."
msgstr ""

#: ../../library/importlib.resources.abc.rst:73
msgid ""
"Returns an :term:`iterable` of strings over the contents of the package. "
"Do note that it is not required that all names returned by the iterator "
"be actual resources, e.g. it is acceptable to return names for which "
":meth:`is_resource` would be false."
msgstr ""

#: ../../library/importlib.resources.abc.rst:79
msgid ""
"Allowing non-resource names to be returned is to allow for situations "
"where how a package and its resources are stored are known a priori and "
"the non-resource names would be useful. For instance, returning "
"subdirectory names is allowed so that when it is known that the package "
"and resources are stored on the file system then those subdirectory names"
" can be used directly."
msgstr ""

#: ../../library/importlib.resources.abc.rst:87
msgid "The abstract method returns an iterable of no items."
msgstr ""

#: ../../library/importlib.resources.abc.rst:92
msgid ""
"An object with a subset of pathlib.Path methods suitable for traversing "
"directories and opening files."
msgstr ""

#: ../../library/importlib.resources.abc.rst:99
msgid "Use :class:`importlib.resources.abc.Traversable` instead."
msgstr ""

#: ../../library/importlib.resources.abc.rst:102
msgid "Abstract. The base name of this object without any parent references."
msgstr ""

#: ../../library/importlib.resources.abc.rst:106
msgid "Yield Traversable objects in self."
msgstr ""

#: ../../library/importlib.resources.abc.rst:110
msgid "Return True if self is a directory."
msgstr ""

#: ../../library/importlib.resources.abc.rst:114
msgid "Return True if self is a file."
msgstr ""

#: ../../library/importlib.resources.abc.rst:118
#: ../../library/importlib.resources.abc.rst:122
msgid "Return Traversable child in self."
msgstr ""

#: ../../library/importlib.resources.abc.rst:126
msgid ""
"*mode* may be 'r' or 'rb' to open as text or binary. Return a handle "
"suitable for reading (same as :attr:`pathlib.Path.open`)."
msgstr ""

#: ../../library/importlib.resources.abc.rst:129
msgid ""
"When opening as text, accepts encoding parameters such as those accepted "
"by :attr:`io.TextIOWrapper`."
msgstr ""

#: ../../library/importlib.resources.abc.rst:134
msgid "Read contents of self as bytes."
msgstr ""

#: ../../library/importlib.resources.abc.rst:138
msgid "Read contents of self as text."
msgstr ""

#: ../../library/importlib.resources.abc.rst:143
msgid ""
"An abstract base class for resource readers capable of serving the "
":meth:`importlib.resources.files` interface. Subclasses "
":class:`importlib.resources.abc.ResourceReader` and provides concrete "
"implementations of the :class:`importlib.resources.abc.ResourceReader`'s "
"abstract methods. Therefore, any loader supplying "
":class:`importlib.abc.TraversableReader` also supplies ResourceReader."
msgstr ""

#: ../../library/importlib.resources.abc.rst:150
msgid ""
"Loaders that wish to support resource reading are expected to implement "
"this interface."
msgstr ""

#: ../../library/importlib.resources.abc.rst:160
msgid ""
"Returns a :class:`importlib.resources.abc.Traversable` object for the "
"loaded package."
msgstr ""

#~ msgid ""
#~ "An abstract base class for a "
#~ ":term:`loader` which implements the optional"
#~ " :pep:`302` protocol for loading arbitrary"
#~ " resources from the storage back-end."
#~ msgstr ""

#~ msgid ""
#~ "This ABC is deprecated in favour "
#~ "of supporting resource loading through "
#~ ":class:`importlib.abc.ResourceReader`."
#~ msgstr ""

#~ msgid ""
#~ "An abstract method to return the "
#~ "bytes for the data located at "
#~ "*path*. Loaders that have a file-"
#~ "like storage back-end that allows "
#~ "storing arbitrary data can implement "
#~ "this abstract method to give direct "
#~ "access to the data stored. "
#~ ":exc:`OSError` is to be raised if "
#~ "the *path* cannot be found. The "
#~ "*path* is expected to be constructed "
#~ "using a module's :attr:`__file__` attribute"
#~ " or an item from a package's "
#~ ":attr:`__path__`."
#~ msgstr ""

#~ msgid "Raises :exc:`OSError` instead of :exc:`NotImplementedError`."
#~ msgstr ""

#~ msgid ""
#~ "An abstract base class for a "
#~ ":term:`loader` which implements the optional"
#~ " :pep:`302` protocol for loaders that "
#~ "inspect modules."
#~ msgstr ""

#~ msgid ""
#~ "Return the code object for a "
#~ "module, or ``None`` if the module "
#~ "does not have a code object (as"
#~ " would be the case, for example, "
#~ "for a built-in module).  Raise an"
#~ " :exc:`ImportError` if loader cannot find"
#~ " the requested module."
#~ msgstr ""

#~ msgid ""
#~ "While the method has a default "
#~ "implementation, it is suggested that it"
#~ " be overridden if possible for "
#~ "performance."
#~ msgstr ""

#~ msgid "No longer abstract and a concrete implementation is provided."
#~ msgstr ""

#~ msgid ""
#~ "An abstract method to return the "
#~ "source of a module. It is returned"
#~ " as a text string using "
#~ ":term:`universal newlines`, translating all "
#~ "recognized line separators into ``'\\n'`` "
#~ "characters.  Returns ``None`` if no "
#~ "source is available (e.g. a built-"
#~ "in module). Raises :exc:`ImportError` if "
#~ "the loader cannot find the module "
#~ "specified."
#~ msgstr ""

#~ msgid "Raises :exc:`ImportError` instead of :exc:`NotImplementedError`."
#~ msgstr ""

#~ msgid ""
#~ "An optional method to return a "
#~ "true value if the module is a "
#~ "package, a false value otherwise. "
#~ ":exc:`ImportError` is raised if the "
#~ ":term:`loader` cannot find the module."
#~ msgstr ""

#~ msgid "Create a code object from Python source."
#~ msgstr ""

#~ msgid ""
#~ "The *data* argument can be whatever "
#~ "the :func:`compile` function supports (i.e."
#~ " string or bytes). The *path* "
#~ "argument should be the \"path\" to "
#~ "where the source code originated from,"
#~ " which can be an abstract concept "
#~ "(e.g. location in a zip file)."
#~ msgstr ""

#~ msgid ""
#~ "With the subsequent code object one "
#~ "can execute it in a module by "
#~ "running ``exec(code, module.__dict__)``."
#~ msgstr ""

#~ msgid "Made the method static."
#~ msgstr ""

#~ msgid "Implementation of :meth:`Loader.exec_module`."
#~ msgstr ""

#~ msgid "Implementation of :meth:`Loader.load_module`."
#~ msgstr ""

#~ msgid "use :meth:`exec_module` instead."
#~ msgstr ""

#~ msgid ""
#~ "An abstract base class which inherits"
#~ " from :class:`InspectLoader` that, when "
#~ "implemented, helps a module to be "
#~ "executed as a script. The ABC "
#~ "represents an optional :pep:`302` protocol."
#~ msgstr ""

#~ msgid ""
#~ "An abstract method that is to "
#~ "return the value of :attr:`__file__` for"
#~ " the specified module. If no path "
#~ "is available, :exc:`ImportError` is raised."
#~ msgstr ""

#~ msgid ""
#~ "If source code is available, then "
#~ "the method should return the path "
#~ "to the source file, regardless of "
#~ "whether a bytecode was used to "
#~ "load the module."
#~ msgstr ""

#~ msgid ""
#~ "An abstract base class which inherits"
#~ " from :class:`ResourceLoader` and "
#~ ":class:`ExecutionLoader`, providing concrete "
#~ "implementations of :meth:`ResourceLoader.get_data` "
#~ "and :meth:`ExecutionLoader.get_filename`."
#~ msgstr ""

#~ msgid ""
#~ "The *fullname* argument is a fully "
#~ "resolved name of the module the "
#~ "loader is to handle. The *path* "
#~ "argument is the path to the file"
#~ " for the module."
#~ msgstr ""

#~ msgid "The name of the module the loader can handle."
#~ msgstr ""

#~ msgid "Path to the file of the module."
#~ msgstr ""

#~ msgid "Calls super's ``load_module()``."
#~ msgstr ""

#~ msgid "Use :meth:`Loader.exec_module` instead."
#~ msgstr ""

#~ msgid "Returns :attr:`path`."
#~ msgstr ""

#~ msgid "Reads *path* as a binary file and returns the bytes from it."
#~ msgstr ""

#~ msgid ""
#~ "An abstract base class for implementing"
#~ " source (and optionally bytecode) file "
#~ "loading. The class inherits from both"
#~ " :class:`ResourceLoader` and :class:`ExecutionLoader`,"
#~ " requiring the implementation of:"
#~ msgstr ""

#~ msgid ":meth:`ResourceLoader.get_data`"
#~ msgstr ""

#~ msgid ":meth:`ExecutionLoader.get_filename`"
#~ msgstr ""

#~ msgid ""
#~ "Should only return the path to the"
#~ " source file; sourceless loading is "
#~ "not supported."
#~ msgstr ""

#~ msgid ""
#~ "The abstract methods defined by this "
#~ "class are to add optional bytecode "
#~ "file support. Not implementing these "
#~ "optional methods (or causing them to "
#~ "raise :exc:`NotImplementedError`) causes the "
#~ "loader to only work with source "
#~ "code. Implementing the methods allows "
#~ "the loader to work with source "
#~ "*and* bytecode files; it does not "
#~ "allow for *sourceless* loading where "
#~ "only bytecode is provided.  Bytecode "
#~ "files are an optimization to speed "
#~ "up loading by removing the parsing "
#~ "step of Python's compiler, and so "
#~ "no bytecode-specific API is exposed."
#~ msgstr ""

#~ msgid ""
#~ "Optional abstract method which returns a"
#~ " :class:`dict` containing metadata about "
#~ "the specified path.  Supported dictionary "
#~ "keys are:"
#~ msgstr ""

#~ msgid ""
#~ "``'mtime'`` (mandatory): an integer or "
#~ "floating-point number representing the "
#~ "modification time of the source code;"
#~ msgstr ""

#~ msgid "``'size'`` (optional): the size in bytes of the source code."
#~ msgstr ""

#~ msgid ""
#~ "Any other keys in the dictionary "
#~ "are ignored, to allow for future "
#~ "extensions. If the path cannot be "
#~ "handled, :exc:`OSError` is raised."
#~ msgstr ""

#~ msgid "Raise :exc:`OSError` instead of :exc:`NotImplementedError`."
#~ msgstr ""

#~ msgid ""
#~ "Optional abstract method which returns "
#~ "the modification time for the specified"
#~ " path."
#~ msgstr ""

#~ msgid ""
#~ "This method is deprecated in favour "
#~ "of :meth:`path_stats`.  You don't have "
#~ "to implement it, but it is still"
#~ " available for compatibility purposes. "
#~ "Raise :exc:`OSError` if the path cannot"
#~ " be handled."
#~ msgstr ""

#~ msgid ""
#~ "Optional abstract method which writes "
#~ "the specified bytes to a file "
#~ "path. Any intermediate directories which "
#~ "do not exist are to be created "
#~ "automatically."
#~ msgstr ""

#~ msgid ""
#~ "When writing to the path fails "
#~ "because the path is read-only "
#~ "(:attr:`errno.EACCES`/:exc:`PermissionError`), do not "
#~ "propagate the exception."
#~ msgstr ""

#~ msgid "No longer raises :exc:`NotImplementedError` when called."
#~ msgstr ""

#~ msgid "Concrete implementation of :meth:`InspectLoader.get_code`."
#~ msgstr ""

#~ msgid "Concrete implementation of :meth:`Loader.exec_module`."
#~ msgstr ""

#~ msgid "Concrete implementation of :meth:`Loader.load_module`."
#~ msgstr ""

#~ msgid "Use :meth:`exec_module` instead."
#~ msgstr ""

#~ msgid "Concrete implementation of :meth:`InspectLoader.get_source`."
#~ msgstr ""

#~ msgid ""
#~ "Concrete implementation of "
#~ ":meth:`InspectLoader.is_package`. A module is "
#~ "determined to be a package if its"
#~ " file path (as provided by "
#~ ":meth:`ExecutionLoader.get_filename`) is a file "
#~ "named ``__init__`` when the file "
#~ "extension is removed **and** the module"
#~ " name itself does not end in "
#~ "``__init__``."
#~ msgstr ""

#~ msgid ""
#~ "An abstract base class for resource "
#~ "readers capable of serving the "
#~ ":meth:`importlib.resources.files` interface. Subclasses"
#~ " :class:`importlib.abc.ResourceReader` and provides "
#~ "concrete implementations of the "
#~ ":class:`importlib.abc.ResourceReader`'s abstract methods."
#~ " Therefore, any loader supplying "
#~ ":class:`importlib.abc.TraversableReader` also supplies "
#~ "ResourceReader."
#~ msgstr ""

#~ msgid ""
#~ "Returns a :class:`importlib.abc.Traversable` object"
#~ " for the loaded package."
#~ msgstr ""

