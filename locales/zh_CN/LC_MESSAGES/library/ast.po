# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2021, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
# Translators:
# Fred <fred.wei@foxmail.com>, 2021
# thautwarm <twshere@outlook.com>, 2021
# Freesand Leo <yuqinju@163.com>, 2021
# Jarry Shaw <jarryshaw@icloud.com>, 2021
# nick <2330458484@qq.com>, 2021
# jaystone776 <1732865113@qq.com>, 2021
# xixi zhao <xixizxx@gmail.com>, 2021
# Dai Xu <daixu61@hotmail.com>, 2021
# Alpha Du <alphanow@gmail.com>, 2021
# xinetzone <735613050@qq.com>, 2021
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-11-21 14:44+0800\n"
"PO-Revision-Date: 2021-06-28 00:54+0000\n"
"Last-Translator: xinetzone <735613050@qq.com>, 2021\n"
"Language: zh_CN\n"
"Language-Team: Chinese (China) (https://www.transifex.com/python-"
"doc/teams/5390/zh_CN/)\n"
"Plural-Forms: nplurals=1; plural=0\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../library/ast.rst:2
msgid ":mod:`ast` --- Abstract Syntax Trees"
msgstr ":mod:`ast` --- 抽象语法树"

#: ../../library/ast.rst:14
msgid "**Source code:** :source:`Lib/ast.py`"
msgstr "**源代码：** :source:`Lib/ast.py`"

#: ../../library/ast.rst:18
msgid ""
"The :mod:`ast` module helps Python applications to process trees of the "
"Python abstract syntax grammar.  The abstract syntax itself might change "
"with each Python release; this module helps to find out programmatically "
"what the current grammar looks like."
msgstr ""
":mod:`ast` 模块帮助 Python 程序处理 Python 语法的抽象语法树。抽象语法或许会随着 Python "
"的更新发布而改变；该模块能够帮助理解当前语法在编程层面的样貌。"

#: ../../library/ast.rst:23
msgid ""
"An abstract syntax tree can be generated by passing "
":data:`ast.PyCF_ONLY_AST` as a flag to the :func:`compile` built-in "
"function, or using the :func:`parse` helper provided in this module.  The"
" result will be a tree of objects whose classes all inherit from "
":class:`ast.AST`.  An abstract syntax tree can be compiled into a Python "
"code object using the built-in :func:`compile` function."
msgstr ""
"抽象语法树可通过将 :data:`ast.PyCF_ONLY_AST` 作为旗标传递给 :func:`compile` "
"内置函数来生成，或是使用此模块中提供的 :func:`parse` 辅助函数。返回结果将是一个对象树，其中的类都继承自 "
":class:`ast.AST`。抽象语法树可被内置的 :func:`compile` 函数编译为一个 Python 代码对象。"

#: ../../library/ast.rst:33
msgid "Abstract Grammar"
msgstr "抽象文法"

#: ../../library/ast.rst:35
msgid "The abstract grammar is currently defined as follows:"
msgstr "抽象文法目前定义如下："

#: ../../library/ast.rst:42
msgid "Node classes"
msgstr "节点类"

#: ../../library/ast.rst:46
msgid ""
"This is the base of all AST node classes.  The actual node classes are "
"derived from the :file:`Parser/Python.asdl` file, which is reproduced "
":ref:`below <abstract-grammar>`.  They are defined in the :mod:`_ast` C "
"module and re-exported in :mod:`ast`."
msgstr ""
"这是所有 AST 节点类的基类。实际上，这些节点类派生自 :file:`Parser/Python.asdl` 文件，其中定义的语法树示例 "
":ref:`如下 <abstract-grammar>`。它们在 C 语言模块 :mod:`_ast` 中定义，并被导出至 :mod:`ast` "
"模块。"

#: ../../library/ast.rst:51
msgid ""
"There is one class defined for each left-hand side symbol in the abstract"
" grammar (for example, :class:`ast.stmt` or :class:`ast.expr`).  In "
"addition, there is one class defined for each constructor on the right-"
"hand side; these classes inherit from the classes for the left-hand side "
"trees.  For example, :class:`ast.BinOp` inherits from :class:`ast.expr`."
"  For production rules with alternatives (aka \"sums\"), the left-hand "
"side class is abstract: only instances of specific constructor nodes are "
"ever created."
msgstr ""
"抽象语法定义的每个左侧符号（比方说， :class:`ast.stmt` 或者 :class:`ast.expr`）定义了一个类。"
"另外，在抽象语法定义的右侧，对每一个构造器也定义了一个类；这些类继承自树左侧的类。"
"比如，:class:`ast.BinOp` 继承自 :class:`ast.expr`。"
"对于多分支产生式（也就是\"和规则\"），树右侧的类是抽象的；只有特定构造器结点的实例能被构造。"

#: ../../library/ast.rst:64
msgid ""
"Each concrete class has an attribute :attr:`_fields` which gives the "
"names of all child nodes."
msgstr "每个具体类都有个属性 :attr:`_fields`, 用来给出所有子节点的名字。 "

#: ../../library/ast.rst:67
msgid ""
"Each instance of a concrete class has one attribute for each child node, "
"of the type as defined in the grammar.  For example, :class:`ast.BinOp` "
"instances have an attribute :attr:`left` of type :class:`ast.expr`."
msgstr ""
"每个具体类的实例对它每个子节点都有一个属性，对应类型如文法中所定义。比如，:class:`ast.BinOp` 的实例有个属性 "
":attr:`left`，类型是 :class:`ast.expr`."

#: ../../library/ast.rst:71
msgid ""
"If these attributes are marked as optional in the grammar (using a "
"question mark), the value might be ``None``.  If the attributes can have "
"zero-or-more values (marked with an asterisk), the values are represented"
" as Python lists.  All possible attributes must be present and have valid"
" values when compiling an AST with :func:`compile`."
msgstr ""
"如果这些属性在文法中标记为可选（使用问号），对应值可能会是 ``None``。"
"如果这些属性有零或多个（用星号标记），对应值会用 Python 的列表来表示。"
"所有可能的属性必须在用 :func:`compile` 编译得到 AST 时给出，且是有效的值。"

#: ../../library/ast.rst:82
msgid ""
"Instances of :class:`ast.expr` and :class:`ast.stmt` subclasses have "
":attr:`lineno`, :attr:`col_offset`, :attr:`end_lineno`, and "
":attr:`end_col_offset` attributes.  The :attr:`lineno` and "
":attr:`end_lineno` are the first and last line numbers of source text "
"span (1-indexed so the first line is line 1) and the :attr:`col_offset` "
"and :attr:`end_col_offset` are the corresponding UTF-8 byte offsets of "
"the first and last tokens that generated the node. The UTF-8 offset is "
"recorded because the parser uses UTF-8 internally."
msgstr ""
":class:`ast.expr` 和 :class:`ast.stmt` 子类的实例有 "
":attr:`lineno`、:attr:`col_offset`、:attr:`end_lineno` 和 :attr:`end_col_offset` 属性。"
":attr:`lineno` 和 :attr:`end_lineno` 是源文本跨度的第一行和最后一行的编号（1-索引，所以第一行是 行1），"
"而 :attr:`col_offset` 和 :attr:`end_col_offset` 是生成该节点的第一个和最后一个形符的相应 UTF-8 字节偏差。"
"UTF-8 的偏移量被记录下来，因为分析器内部使用 UTF-8。"

#: ../../library/ast.rst:91
msgid ""
"Note that the end positions are not required by the compiler and are "
"therefore optional. The end offset is *after* the last symbol, for "
"example one can get the source segment of a one-line expression node "
"using ``source_line[node.col_offset : node.end_col_offset]``."
msgstr ""
"请注意，编译器不要求结束位置，因此是可选的。"
"末端偏移量是在最后一个符号之后，例如可以用 "
"``source_line[node.col_offset : node.end_col_offset]`` "
"得到单行表达式节点的源片段。"

#: ../../library/ast.rst:96
msgid "The constructor of a class :class:`ast.T` parses its arguments as follows:"
msgstr "类的构造器 :class:`ast.T` 像下面这样解析它的参数："

#: ../../library/ast.rst:98
msgid ""
"If there are positional arguments, there must be as many as there are "
"items in :attr:`T._fields`; they will be assigned as attributes of these "
"names."
msgstr ""
"如果有位置参数，它们必须和 :attr:`T._fields` 中的元素一样多；他们会像这些名字的属性一样被赋值。"

#: ../../library/ast.rst:100
msgid ""
"If there are keyword arguments, they will set the attributes of the same "
"names to the given values."
msgstr "如果有关键字参数，它们必须被设为和给定值同名的属性。"

#: ../../library/ast.rst:103
msgid ""
"For example, to create and populate an :class:`ast.UnaryOp` node, you "
"could use ::"
msgstr "比方说，要创建和填充节点 :class:`ast.UnaryOp`，你得用 ::"

#: ../../library/ast.rst:115
msgid "or the more compact ::"
msgstr "或者更紧凑点 ::"

#: ../../library/ast.rst:122
msgid "Class :class:`ast.Constant` is now used for all constants."
msgstr "类 :class:`ast.Constant` 现用于所有常量。"

#: ../../library/ast.rst:126
msgid ""
"Simple indices are represented by their value, extended slices are "
"represented as tuples."
msgstr ""
"简单的索引用其值表示，扩展的切片用元组表示。"

#: ../../library/ast.rst:131
msgid ""
"Old classes :class:`ast.Num`, :class:`ast.Str`, :class:`ast.Bytes`, "
":class:`ast.NameConstant` and :class:`ast.Ellipsis` are still available, "
"but they will be removed in future Python releases.  In the meantime, "
"instantiating them will return an instance of a different class."
msgstr ""
"旧的类 "
":class:`ast.Num`、:class:`ast.Str`、:class:`ast.Bytes`、:class:`ast.NameConstant` "
"和 :class:`ast.Ellipsis` 仍然可用，但它们将在未来的 Python 版本中被删除。"
"在此期间，实例化它们将返回一个不同类的实例。"

#: ../../library/ast.rst:138
msgid ""
"Old classes :class:`ast.Index` and :class:`ast.ExtSlice` are still "
"available, but they will be removed in future Python releases. In the "
"meantime, instantiating them will return an instance of a different "
"class."
msgstr ""
"旧的类 :class:`ast.Index` 和 :class:`ast.ExtSlice` 仍然可用，"
"但它们将在未来的 Python 版本中被移除。在此期间，实例化它们将返回一个不同类的实例。"

#: ../../library/ast.rst:144
msgid ""
"The descriptions of the specific node classes displayed here were "
"initially adapted from the fantastic `Green Tree Snakes "
"<https://greentreesnakes.readthedocs.io/en/latest/>`__ project and all "
"its contributors."
msgstr ""
"这里显示的具体节点类的描述最初是从神奇的 "
"`绿色树蛇 <https://greentreesnakes.readthedocs.io/en/latest/>`__ "
"项目及其所有贡献者那里改编的。"

#: ../../library/ast.rst:150
msgid "Literals"
msgstr "字面值"

#: ../../library/ast.rst:154
msgid ""
"A constant value. The ``value`` attribute of the ``Constant`` literal "
"contains the Python object it represents. The values represented can be "
"simple types such as a number, string or ``None``, but also immutable "
"container types (tuples and frozensets) if all of their elements are "
"constant."
msgstr ""
"一个常量值。"
"``Constant`` 字面的 ``value`` 属性包含它所代表的 Python 对象。"
"所代表的值可以是简单的类型，如数字、字符串或 ``None``，"
"也可以是不可变的容器类型（tuple 和 frozenset），如果它们的所有元素都是常数的话。"

#: ../../library/ast.rst:168
msgid ""
"Node representing a single formatting field in an f-string. If the string"
" contains a single formatting field and nothing else the node can be "
"isolated otherwise it appears in :class:`JoinedStr`."
msgstr ""
"代表 f-string 中单一格式化字段的节点。"
"如果字符串包含一个单一的格式化字段，而没有其他内容，那么该节点可以被隔离，"
"否则它将出现在 :class:`JoinedStr` 中。"

#: ../../library/ast.rst:172
msgid ""
"``value`` is any expression node (such as a literal, a variable, or a "
"function call)."
msgstr ""
"``value`` 是任何表达式节点（如字面值、变量或函数调用）。"

#: ../../library/ast.rst:174
msgid "``conversion`` is an integer:"
msgstr "``conversion`` 是整数："

#: ../../library/ast.rst:176
msgid "-1: no formatting"
msgstr "-1：没有格式化"

#: ../../library/ast.rst:177
msgid "115: ``!s`` string formatting"
msgstr "115：``!s`` 字符串格式化"

#: ../../library/ast.rst:178
msgid "114: ``!r`` repr formatting"
msgstr "114：``!r`` repr 格式化"

#: ../../library/ast.rst:179
msgid "97: ``!a`` ascii formatting"
msgstr "97：``!a`` ascii 格式化"

#: ../../library/ast.rst:181
msgid ""
"``format_spec`` is a :class:`JoinedStr` node representing the formatting "
"of the value, or ``None`` if no format was specified. Both ``conversion``"
" and ``format_spec`` can be set at the same time."
msgstr ""
"``format_spec`` 是一个 :class:`JoinedStr` 节点，代表值的格式化，"
"如果没有指定格式，则为 ``None``。``conversion`` 和 ``format_spec`` 都可以同时设置。"

#: ../../library/ast.rst:188
msgid ""
"An f-string, comprising a series of :class:`FormattedValue` and "
":class:`Constant` nodes."
msgstr ""
"f-string，包括一系列的 :class:`FormattedValue` 和 :class:`Constant` 节点。"

#: ../../library/ast.rst:217
msgid ""
"A list or tuple. ``elts`` holds a list of nodes representing the "
"elements. ``ctx`` is :class:`Store` if the container is an assignment "
"target (i.e. ``(x,y)=something``), and :class:`Load` otherwise."
msgstr ""
"一个列表或元组。``elts`` 持有代表其元素的节点列表。"
"如果容器是一个赋值目标（即 ``(x,y)=something``），``ctx`` 是 :class:`Store`，否则 :class:`Load`。"

#: ../../library/ast.rst:243
msgid "A set. ``elts`` holds a list of nodes representing the set's elements."
msgstr "集合。``elts`` 持有代表该集合元素的节点列表。"

#: ../../library/ast.rst:258
msgid ""
"A dictionary. ``keys`` and ``values`` hold lists of nodes representing "
"the keys and the values respectively, in matching order (what would be "
"returned when calling :code:`dictionary.keys()` and "
":code:`dictionary.values()`)."
msgstr ""
"字典。``keys`` 和 ``values`` 分别持有代表其键和值的节点列表，"
"顺序匹配（当调用 :code:`dictionary.keys()` 和 :code:`dictionary.values()` 时将会返回）。"

#: ../../library/ast.rst:262
msgid ""
"When doing dictionary unpacking using dictionary literals the expression "
"to be expanded goes in the ``values`` list, with a ``None`` at the "
"corresponding position in ``keys``."
msgstr ""
"当使用字典字元进行字典解包时，要展开的表达式在 ``values`` 列表中，在 ``keys`` 的相应位置有一个  ``None`` 。"

#: ../../library/ast.rst:280
msgid "Variables"
msgstr "变量"

#: ../../library/ast.rst:284
msgid ""
"A variable name. ``id`` holds the name as a string, and ``ctx`` is one of"
" the following types."
msgstr ""
"变量名称。``id`` 持有作为字符串的名称，``ctx`` 是以下类型之一。"

#: ../../library/ast.rst:292
msgid ""
"Variable references can be used to load the value of a variable, to "
"assign a new value to it, or to delete it. Variable references are given "
"a context to distinguish these cases."
msgstr ""
"变量引用可以用来加载变量的值、给它分配新的值或者删除它。变量引用被赋予一个上下文以区分这些情况。"

#: ../../library/ast.rst:325
msgid ""
"A ``*var`` variable reference. ``value`` holds the variable, typically a "
":class:`Name` node. This type must be used when building a :class:`Call` "
"node with ``*args``."
msgstr ""
"``*var`` 的变量引用。"
"``value`` 持有变量，通常是一个 :class:`Name` 节点。"
"当建立一个带有 ``*args`` 的 :class:`Call` 节点时，必须使用这种类型。"

#: ../../library/ast.rst:348
msgid "Expressions"
msgstr "表达式"

#: ../../library/ast.rst:352
msgid ""
"When an expression, such as a function call, appears as a statement by "
"itself with its return value not used or stored, it is wrapped in this "
"container. ``value`` holds one of the other nodes in this section, a "
":class:`Constant`, a :class:`Name`, a :class:`Lambda`, a :class:`Yield` "
"or :class:`YieldFrom` node."
msgstr ""
"当一个表达式，比如一个函数调用，本身作为一个语句出现，其返回值没有被使用或存储，"
"它被包裹在这个容器中。``value`` 容纳本节中的一个其他节点，"
":class:`Constant`、:class:`Name`、:class:`Lambda`、:class:`Yield` 或 :class:`YieldFrom` 节点。"

#: ../../library/ast.rst:371
msgid ""
"A unary operation. ``op`` is the operator, and ``operand`` any expression"
" node."
msgstr ""
"一元运算。``op`` 是运算符，``operand`` 是任何表达式节点。"

#: ../../library/ast.rst:380
msgid ""
"Unary operator tokens. :class:`Not` is the ``not`` keyword, "
":class:`Invert` is the ``~`` operator."
msgstr ""
"一元运算形符。:class:`Not` 是 ``not`` 关键字、:class:`Invert` 是 ``~`` 运算符。"

#: ../../library/ast.rst:394
msgid ""
"A binary operation (like addition or division). ``op`` is the operator, "
"and ``left`` and ``right`` are any expression nodes."
msgstr ""
"二元运算（如加法或除法）。``op`` 是运算符，``left`` 和 ``right`` 是任何表达式节点。"

#: ../../library/ast.rst:421
msgid "Binary operator tokens."
msgstr "二元运算符的形符。"

#: ../../library/ast.rst:426
msgid ""
"A boolean operation, 'or' or 'and'. ``op`` is :class:`Or` or "
":class:`And`. ``values`` are the values involved. Consecutive operations "
"with the same operator, such as ``a or b or c``, are collapsed into one "
"node with several values."
msgstr ""
"一个布尔运算，'or' 或 'and'。``op`` 是 :class:`Or` 或 :class:`And`。"
"``values`` 是所涉及的值。"
"具有相同操作符的连续操作，如 ``a or b or c``，会被折叠成一个具有几个值的节点。"

#: ../../library/ast.rst:431
msgid "This doesn't include ``not``, which is a :class:`UnaryOp`."
msgstr "这不包括 ``not``，它是一个 :class:`UnaryOp`。"

#: ../../library/ast.rst:447
msgid "Boolean operator tokens."
msgstr "布尔运算形符。"

#: ../../library/ast.rst:452
msgid ""
"A comparison of two or more values. ``left`` is the first value in the "
"comparison, ``ops`` the list of operators, and ``comparators`` the list "
"of values after the first element in the comparison."
msgstr ""
"两个或多个值的比较。``left`` 是比较中的第一个值，``ops`` 是运算符的列表，"
"``comparators`` 是比较中第一个元素之后的值列表。"

#: ../../library/ast.rst:481
msgid "Comparison operator tokens."
msgstr "比较运算形符。"

#: ../../library/ast.rst:486
msgid ""
"A function call. ``func`` is the function, which will often be a "
":class:`Name` or :class:`Attribute` object. Of the arguments:"
msgstr ""
"一个函数调用。``func`` 是函数，通常是一个 :class:`Name` 或 :class:`Attribute` 对象。参数："

#: ../../library/ast.rst:489
msgid "``args`` holds a list of the arguments passed by position."
msgstr "``args`` 持有一个由位置传递的参数列表。"

#: ../../library/ast.rst:490
msgid ""
"``keywords`` holds a list of :class:`keyword` objects representing "
"arguments passed by keyword."
msgstr ""
"``keywords`` 持有一个 :class:`keyword` 对象的列表，代表由 keyword 传递的参数。"

#: ../../library/ast.rst:493
msgid ""
"When creating a ``Call`` node, ``args`` and ``keywords`` are required, "
"but they can be empty lists. ``starargs`` and ``kwargs`` are optional."
msgstr ""
"当创建一个 ``Call`` 节点时，``args`` 和 ``keywords`` 是必须的，但它们可以是空列表。"
"``starargs`` 和 ``kwargs`` 是可选的。"

#: ../../library/ast.rst:517
msgid ""
"A keyword argument to a function call or class definition. ``arg`` is a "
"raw string of the parameter name, ``value`` is a node to pass in."
msgstr ""
"一个函数调用或类定义的关键字参数。``arg`` 是参数名称的原始字符串，``value`` 是要传入的节点。"

#: ../../library/ast.rst:523
msgid ""
"An expression such as ``a if b else c``. Each field holds a single node, "
"so in the following example, all three are :class:`Name` nodes."
msgstr ""
"一个表达式，如 ``a if b else c``。"
"每个字段持有一个节点，所以在下面的例子中，三个都是 :class:`Name` 节点"。

#: ../../library/ast.rst:538
msgid ""
"Attribute access, e.g. ``d.keys``. ``value`` is a node, typically a "
":class:`Name`. ``attr`` is a bare string giving the name of the "
"attribute, and ``ctx`` is :class:`Load`, :class:`Store` or :class:`Del` "
"according to how the attribute is acted on."
msgstr ""
"属性访问，例如：``d.keys``。``value`` 是一个节点，通常是 :class:`Name`。"
"``attr`` 是一个裸字符串，给出属性的名称，"
"``ctx`` 是 :class:`Load`、:class:`Store` 或 :class:`Del`，根据属性的操作方式。"

#: ../../library/ast.rst:555
msgid ""
"A named expression. This AST node is produced by the assignment "
"expressions operator (also known as the walrus operator). As opposed to "
"the :class:`Assign` node in which the first argument can be multiple "
"nodes, in this case both ``target`` and ``value`` must be single nodes."
msgstr ""
"一个命名的表达式。这个 AST 节点是由赋值表达式运算符（也被称为海象运算符）产生的。"
"相对于 :class:`Assign` 节点，其中第一个参数可以是多个节点，在这种情况下，"
"``target`` 和 ``value`` 都必须是单个节点。"

#: ../../library/ast.rst:570
msgid "Subscripting"
msgstr "下标"

#: ../../library/ast.rst:574
msgid ""
"A subscript, such as ``l[1]``. ``value`` is the subscripted object "
"(usually sequence or mapping). ``slice`` is an index, slice or key. It "
"can be a :class:`Tuple` and contain a :class:`Slice`. ``ctx`` is "
":class:`Load`, :class:`Store` or :class:`Del` according to the action "
"performed with the subscript."
msgstr ""
"一个下标，例如 ``l[1]``。"
"``value`` 是下标的对象（通常是序列或映射）。"
"``slice`` 是一个索引、切片或键。"
"它可以是一个 :class:`Tuple` 并包含一个 :class:`Slice`。"
"``ctx`` 是 :class:`Load`、:class:`Store` 或 :class:`Del`，根据对下标执行的操作。"

#: ../../library/ast.rst:598
msgid ""
"Regular slicing (on the form ``lower:upper`` or ``lower:upper:step``). "
"Can occur only inside the *slice* field of :class:`Subscript`, either "
"directly or as an element of :class:`Tuple`."
msgstr ""
"常规切片（形式为 ``lower:upper`` 或 ``lower:upper:step``）。"
"只能出现在 :class:`subscript` 的 *slice* 字段内，可以直接出现，也可以作为 :class:`Tuple` 的一个元素出现。"

#: ../../library/ast.rst:615
msgid "Comprehensions"
msgstr "解析式"

#: ../../library/ast.rst:622
msgid ""
"List and set comprehensions, generator expressions, and dictionary "
"comprehensions. ``elt`` (or ``key`` and ``value``) is a single node "
"representing the part that will be evaluated for each item."
msgstr ""
"列表和集合的解析式，生成器表达式和字典的解析式。"
"``elt``（或 ``key`` 和 ``value``）是一个单一的节点，代表每个项将被评估的部分。"

#: ../../library/ast.rst:626
msgid "``generators`` is a list of :class:`comprehension` nodes."
msgstr "``generators`` 是一个 :class:`comprehension` 节点的列表。"

#: ../../library/ast.rst:668
msgid ""
"One ``for`` clause in a comprehension. ``target`` is the reference to use"
" for each element - typically a :class:`Name` or :class:`Tuple` node. "
"``iter`` is the object to iterate over. ``ifs`` is a list of test "
"expressions: each ``for`` clause can have multiple ``ifs``."
msgstr ""
"在一个解析式中的一个 ``for`` 子句。"
"``target`` 是每个元素的引用 - 通常是一个 :class:`Name` 或 :class:`Tuple` 节点。"
"``iter`` 是要迭代的对象。``ifs`` 是测试表达式的列表：每个 ``for`` 子句可以有多个 ``ifs``。"

#: ../../library/ast.rst:673
msgid ""
"``is_async`` indicates a comprehension is asynchronous (using an ``async "
"for`` instead of ``for``). The value is an integer (0 or 1)."
msgstr ""
"``is_async`` 表示一个解析式是异步的（使用 ``async for`` 而不是 ``for``）。"
"其值是一个整数（0 或 1）。"

#: ../../library/ast.rst:739
msgid "Statements"
msgstr "语句"

#: ../../library/ast.rst:743
msgid ""
"An assignment. ``targets`` is a list of nodes, and ``value`` is a single "
"node."
msgstr ""
"赋值。``targets`` 是一个节点列表，``value`` 是一个单一节点。"

#: ../../library/ast.rst:745
msgid ""
"Multiple nodes in ``targets`` represents assigning the same value to "
"each. Unpacking is represented by putting a :class:`Tuple` or "
":class:`List` within ``targets``."
msgstr ""
"``targets`` 中的多个节点代表给每个节点分配相同的值。"
"解包是通过在 ``targets`` 内放置一个 :class:`Tuple` 或 :class:`List` 来表示。"

#: ../../library/ast.rst:751 ../../library/ast.rst:1038
#: ../../library/ast.rst:1211 ../../library/ast.rst:1632
msgid ""
"``type_comment`` is an optional string with the type annotation as a "
"comment."
msgstr ""
"``type_comment`` 是一个可选的字符串，其中的类型注释是一个注释。"

#: ../../library/ast.rst:781
msgid ""
"An assignment with a type annotation. ``target`` is a single node and can"
" be a :class:`Name`, a :class:`Attribute` or a :class:`Subscript`. "
"``annotation`` is the annotation, such as a :class:`Constant` or "
":class:`Name` node. ``value`` is a single optional node. ``simple`` is a "
"boolean integer set to True for a :class:`Name` node in ``target`` that "
"do not appear in between parenthesis and are hence pure names and not "
"expressions."
msgstr ""
"一个带有类型注释的赋值。"
"``target`` 是一个单一的节点，可以是 :class:`Name`、:class:`Attribute` 或一个 :class:`Subscript`。"
"``annotation`` 是注释，例如 :class:`Constant` 或 :class:`Name` 节点。"
"``value`` 是一个单一的可选节点。``simple`` 是一个布尔整数，"
"对于 ``target`` 中的 :class:`Name` 节点，设置为 True，不出现在括号之间，因此是纯名称，不是表达式。"

#: ../../library/ast.rst:836
msgid ""
"Augmented assignment, such as ``a += 1``. In the following example, "
"``target`` is a :class:`Name` node for ``x`` (with the :class:`Store` "
"context), ``op`` is :class:`Add`, and ``value`` is a :class:`Constant` "
"with value for 1."
msgstr ""
"增强的赋值，如 ``a += 1``。"
"在下面的例子中，``target`` 是 ``x`` 的一个 :class:`Name` 节点"
"（有 :class:`Store` 上下文），``op`` 是 :class:`Add`，``value`` 是一个 :class:`Constant`，值为 1。"

#: ../../library/ast.rst:841
msgid ""
"The ``target`` attribute cannot be of class :class:`Tuple` or "
":class:`List`, unlike the targets of :class:`Assign`."
msgstr ""
"与 :class:`Assign` 的 targets 不同，``target`` 属性不能是 :class:`Tuple` 或 :class:`List` 类。"

#: ../../library/ast.rst:858
msgid ""
"A ``raise`` statement. ``exc`` is the exception object to be raised, "
"normally a :class:`Call` or :class:`Name`, or ``None`` for a standalone "
"``raise``. ``cause`` is the optional part for ``y`` in ``raise x from "
"y``."
msgstr ""
"``raise`` 语句。"
"``exc`` 是要引发的异常对象，通常是 :class:`Call` 或 :class:`Name`，"
"或 ``None`` 用于独立的 ``raise``。"
"``cause`` 是 ``raise x from y`` 中 ``y`` 的可选部分。"

#: ../../library/ast.rst:875
msgid ""
"An assertion. ``test`` holds the condition, such as a :class:`Compare` "
"node. ``msg`` holds the failure message."
msgstr ""
"断言。``test`` 持有条件，例如 :class:`Compare` 节点。``msg`` 持有失败信息。"

#: ../../library/ast.rst:891
msgid ""
"Represents a ``del`` statement. ``targets`` is a list of nodes, such as "
":class:`Name`, :class:`Attribute` or :class:`Subscript` nodes."
msgstr ""
"代表一个 ``del`` 语句。"
"``targets`` 是一个节点列表，例如 :class:`Name`、:class:`Attribute` 或 :class:`Subscript` 的节点。"

#: ../../library/ast.rst:909
msgid "A ``pass`` statement."
msgstr "``pass`` 语句。"

#: ../../library/ast.rst:920
msgid ""
"Other statements which are only applicable inside functions or loops are "
"described in other sections."
msgstr ""
"其他只适用于函数或循环内部的语句在其他章节中描述。"

#: ../../library/ast.rst:924
msgid "Imports"
msgstr ""

#: ../../library/ast.rst:928
msgid "An import statement. ``names`` is a list of :class:`alias` nodes."
msgstr "导入语句。``names`` 是一个 :class:`alias` 节点的列表。"

#: ../../library/ast.rst:945
msgid ""
"Represents ``from x import y``. ``module`` is a raw string of the 'from' "
"name, without any leading dots, or ``None`` for statements such as ``from"
" . import foo``. ``level`` is an integer holding the level of the "
"relative import (0 means absolute import)."
msgstr ""
"代表 ``from x import y``。"
"``module`` 是 'from' 名称的原始字符串，没有任何前导点，"
"或 ``None`` 用于诸如 ``from . foo`` 的语句。"
"``level`` 是一个整数，表示相对导入的级别（0 表示绝对导入）。"

#: ../../library/ast.rst:967
msgid ""
"Both parameters are raw strings of the names. ``asname`` can be ``None`` "
"if the regular name is to be used."
msgstr ""
"两个参数都是名字的原始字符串。如果要使用常规名称，``asname`` 可以是 ``None``。"

#: ../../library/ast.rst:984
msgid "Control flow"
msgstr "控制流"

#: ../../library/ast.rst:987
msgid ""
"Optional clauses such as ``else`` are stored as an empty list if they're "
"not present."
msgstr ""
"像 ``else`` 这样的可选子句，如果不存在，就会被存储为一个空列表。"

#: ../../library/ast.rst:992
msgid ""
"An ``if`` statement. ``test`` holds a single node, such as a "
":class:`Compare` node. ``body`` and ``orelse`` each hold a list of nodes."
msgstr ""
"``if`` 语句。``test`` 持有一个节点，例如 :class:`Compare` 节点。"
"``body`` 和 ``orelse`` 分别持有一个节点的列表。"

#: ../../library/ast.rst:995
msgid ""
"``elif`` clauses don't have a special representation in the AST, but "
"rather appear as extra :class:`If` nodes within the ``orelse`` section of"
" the previous one."
msgstr ""
"``elif`` 子句在 AST 中没有特殊的表示方法，"
"而是作为额外的 :class:`If` 节点出现在前一个子句的 ``orelse`` 部分。"

#: ../../library/ast.rst:1030
msgid ""
"A ``for`` loop. ``target`` holds the variable(s) the loop assigns to, as "
"a single :class:`Name`, :class:`Tuple` or :class:`List` node. ``iter`` "
"holds the item to be looped over, again as a single node. ``body`` and "
"``orelse`` contain lists of nodes to execute. Those in ``orelse`` are "
"executed if the loop finishes normally, rather than via a ``break`` "
"statement."
msgstr ""
"``for`` 循环。"
"``target`` 持有循环指定的变量，作为一个单独的 :class:`Name`、:class:`Tuple` 或 :class:`List` 节点。"
"``iter`` 持有要被循环的项目，同样是一个节点。``body`` 和 ``orelse`` 包含要执行的节点列表。"
"如果循环正常结束，``orelse`` 中的节点将被执行，而不是通过 ``break`` 语句。"

#: ../../library/ast.rst:1064
msgid ""
"A ``while`` loop. ``test`` holds the condition, such as a "
":class:`Compare` node."
msgstr ""
"``while`` 循环。``test`` 持有条件，例如 :class:`Compare` 节点。"

#: ../../library/ast.rst:1091
msgid "The ``break`` and ``continue`` statements."
msgstr "``break`` 和 ``continue`` 语句。"

#: ../../library/ast.rst:1126
msgid ""
"``try`` blocks. All attributes are list of nodes to execute, except for "
"``handlers``, which is a list of :class:`ExceptHandler` nodes."
msgstr ""
"``try`` 块。所有属性都是要执行的节点列表，除了 ``handlers``，它是 :class:`ExceptHandler` 节点的列表。"

#: ../../library/ast.rst:1172
msgid ""
"A single ``except`` clause. ``type`` is the exception type it will match,"
" typically a :class:`Name` node (or ``None`` for a catch-all ``except:`` "
"clause). ``name`` is a raw string for the name to hold the exception, or "
"``None`` if the clause doesn't have ``as foo``. ``body`` is a list of "
"nodes."
msgstr ""
"一个单一的 ``except`` 子句。"
"``type`` 是它要匹配的异常类型，通常是 :class:`Name` 节点（或者 ``None`` 是一个全面的 ``except:`` 子句）。"
"``name`` 是一个原始字符串，用于保存异常的名称，如果子句中没有 ``as foo``，则为 ``None``。"
"``body`` 是一个节点的列表。"

#: ../../library/ast.rst:1206
msgid ""
"A ``with`` block. ``items`` is a list of :class:`withitem` nodes "
"representing the context managers, and ``body`` is the indented block "
"inside the context."
msgstr ""
"``with`` 块。``items`` 是一个代表上下文管理者的 :class:`withitem` 节点的列表，``body`` 是上下文中缩进的块。"

#: ../../library/ast.rst:1216
msgid ""
"A single context manager in a ``with`` block. ``context_expr`` is the "
"context manager, often a :class:`Call` node. ``optional_vars`` is a "
":class:`Name`, :class:`Tuple` or :class:`List` for the ``as foo`` part, "
"or ``None`` if that isn't used."
msgstr ""
"``with`` 区块中的单个上下文管理器。``context_expr`` 是上下文管理器，通常是一个 :class:`Call` 节点。"
"``optional_vars`` 是 :class:`Name`、:class:`Tuple` "
"或 :class:`List` 的 ``as foo`` 部分，如果不使用，则为 ``None``。"

#: ../../library/ast.rst:1249
msgid "Pattern matching"
msgstr ""

#: ../../library/ast.rst:1254
msgid ""
"A ``match`` statement. ``subject`` holds the subject of the match (the "
"object that is being matched against the cases) and ``cases`` contains an"
" iterable of :class:`match_case` nodes with the different cases."
msgstr ""

#: ../../library/ast.rst:1260
msgid ""
"A single case pattern in a ``match`` statement. ``pattern`` contains the "
"match pattern that the subject will be matched against. Note that the "
":class:`AST` nodes produced for patterns differ from those produced for "
"expressions, even when they share the same syntax."
msgstr ""

#: ../../library/ast.rst:1265
msgid ""
"The ``guard`` attribute contains an expression that will be evaluated if "
"the pattern matches the subject."
msgstr ""

#: ../../library/ast.rst:1268
msgid ""
"``body`` contains a list of nodes to execute if the pattern matches and "
"the result of evaluating the guard expression is true."
msgstr ""

#: ../../library/ast.rst:1311
msgid ""
"A match literal or value pattern that compares by equality. ``value`` is "
"an expression node. Permitted value nodes are restricted as described in "
"the match statement documentation. This pattern succeeds if the match "
"subject is equal to the evaluated value."
msgstr ""

#: ../../library/ast.rst:1338
msgid ""
"A match literal pattern that compares by identity. ``value`` is the "
"singleton to be compared against: ``None``, ``True``, or ``False``. This "
"pattern succeeds if the match subject is the given constant."
msgstr ""

#: ../../library/ast.rst:1363
msgid ""
"A match sequence pattern. ``patterns`` contains the patterns to be "
"matched against the subject elements if the subject is a sequence. "
"Matches a variable length sequence if one of the subpatterns is a "
"``MatchStar`` node, otherwise matches a fixed length sequence."
msgstr ""

#: ../../library/ast.rst:1394
msgid ""
"Matches the rest of the sequence in a variable length match sequence "
"pattern. If ``name`` is not ``None``, a list containing the remaining "
"sequence elements is bound to that name if the overall sequence pattern "
"is successful."
msgstr ""

#: ../../library/ast.rst:1434
msgid ""
"A match mapping pattern. ``keys`` is a sequence of expression nodes. "
"``patterns`` is a corresponding sequence of pattern nodes. ``rest`` is an"
" optional name that can be specified to capture the remaining mapping "
"elements. Permitted key expressions are restricted as described in the "
"match statement documentation."
msgstr ""

#: ../../library/ast.rst:1440
msgid ""
"This pattern succeeds if the subject is a mapping, all evaluated key "
"expressions are present in the mapping, and the value corresponding to "
"each key matches the corresponding subpattern. If ``rest`` is not "
"``None``, a dict containing the remaining mapping elements is bound to "
"that name if the overall mapping pattern is successful."
msgstr ""

#: ../../library/ast.rst:1480
msgid ""
"A match class pattern. ``cls`` is an expression giving the nominal class "
"to be matched. ``patterns`` is a sequence of pattern nodes to be matched "
"against the class defined sequence of pattern matching attributes. "
"``kwd_attrs`` is a sequence of additional attributes to be matched "
"(specified as keyword arguments in the class pattern), ``kwd_patterns`` "
"are the corresponding patterns (specified as keyword values in the class "
"pattern)."
msgstr ""

#: ../../library/ast.rst:1487
msgid ""
"This pattern succeeds if the subject is an instance of the nominated "
"class, all positional patterns match the corresponding class-defined "
"attributes, and any specified keyword attributes match their "
"corresponding pattern."
msgstr ""

#: ../../library/ast.rst:1491
msgid ""
"Note: classes may define a property that returns self in order to match a"
" pattern node against the instance being matched. Several builtin types "
"are also matched that way, as described in the match statement "
"documentation."
msgstr ""

#: ../../library/ast.rst:1544
msgid ""
"A match \"as-pattern\", capture pattern or wildcard pattern. ``pattern`` "
"contains the match pattern that the subject will be matched against. If "
"the pattern is ``None``, the node represents a capture pattern (i.e a "
"bare name) and will always succeed."
msgstr ""

#: ../../library/ast.rst:1549
msgid ""
"The ``name`` attribute contains the name that will be bound if the "
"pattern is successful. If ``name`` is ``None``, ``pattern`` must also be "
"``None`` and the node represents the wildcard pattern."
msgstr ""

#: ../../library/ast.rst:1585
msgid ""
"A match \"or-pattern\". An or-pattern matches each of its subpatterns in "
"turn to the subject, until one succeeds. The or-pattern is then deemed to"
" succeed. If none of the subpatterns succeed the or-pattern fails. The "
"``patterns`` attribute contains a list of match pattern nodes that will "
"be matched against the subject."
msgstr ""

#: ../../library/ast.rst:1617
msgid "Function and class definitions"
msgstr ""

#: ../../library/ast.rst:1621
msgid "A function definition."
msgstr ""

#: ../../library/ast.rst:1623
msgid "``name`` is a raw string of the function name."
msgstr ""

#: ../../library/ast.rst:1624
msgid "``args`` is an :class:`arguments` node."
msgstr ""

#: ../../library/ast.rst:1625
msgid "``body`` is the list of nodes inside the function."
msgstr ""

#: ../../library/ast.rst:1626
msgid ""
"``decorator_list`` is the list of decorators to be applied, stored "
"outermost first (i.e. the first in the list will be applied last)."
msgstr ""

#: ../../library/ast.rst:1628
msgid "``returns`` is the return annotation."
msgstr ""

#: ../../library/ast.rst:1637
msgid ""
"``lambda`` is a minimal function definition that can be used inside an "
"expression. Unlike :class:`FunctionDef`, ``body`` holds a single node."
msgstr ""

#: ../../library/ast.rst:1661
msgid "The arguments for a function."
msgstr ""

#: ../../library/ast.rst:1663
msgid ""
"``posonlyargs``, ``args`` and ``kwonlyargs`` are lists of :class:`arg` "
"nodes."
msgstr ""

#: ../../library/ast.rst:1664
msgid ""
"``vararg`` and ``kwarg`` are single :class:`arg` nodes, referring to the "
"``*args, **kwargs`` parameters."
msgstr ""

#: ../../library/ast.rst:1666
msgid ""
"``kw_defaults`` is a list of default values for keyword-only arguments. "
"If one is ``None``, the corresponding argument is required."
msgstr ""

#: ../../library/ast.rst:1668
msgid ""
"``defaults`` is a list of default values for arguments that can be passed"
" positionally. If there are fewer defaults, they correspond to the last n"
" arguments."
msgstr ""

#: ../../library/ast.rst:1675
msgid ""
"A single argument in a list. ``arg`` is a raw string of the argument "
"name, ``annotation`` is its annotation, such as a :class:`Str` or "
":class:`Name` node."
msgstr ""

#: ../../library/ast.rst:1681
msgid ""
"``type_comment`` is an optional string with the type annotation as a "
"comment"
msgstr ""

#: ../../library/ast.rst:1725
msgid "A ``return`` statement."
msgstr ""

#: ../../library/ast.rst:1740
msgid ""
"A ``yield`` or ``yield from`` expression. Because these are expressions, "
"they must be wrapped in a :class:`Expr` node if the value sent back is "
"not used."
msgstr ""

#: ../../library/ast.rst:1765
msgid ""
"``global`` and ``nonlocal`` statements. ``names`` is a list of raw "
"strings."
msgstr ""

#: ../../library/ast.rst:1792
msgid "A class definition."
msgstr ""

#: ../../library/ast.rst:1794
msgid "``name`` is a raw string for the class name"
msgstr ""

#: ../../library/ast.rst:1795
msgid "``bases`` is a list of nodes for explicitly specified base classes."
msgstr ""

#: ../../library/ast.rst:1796
msgid ""
"``keywords`` is a list of :class:`keyword` nodes, principally for "
"'metaclass'. Other keywords will be passed to the metaclass, as per "
"`PEP-3115 <https://www.python.org/dev/peps/pep-3115/>`_."
msgstr ""

#: ../../library/ast.rst:1799
msgid ""
"``starargs`` and ``kwargs`` are each a single node, as in a function "
"call. starargs will be expanded to join the list of base classes, and "
"kwargs will be passed to the metaclass."
msgstr ""

#: ../../library/ast.rst:1802
msgid ""
"``body`` is a list of nodes representing the code within the class "
"definition."
msgstr ""

#: ../../library/ast.rst:1804
msgid "``decorator_list`` is a list of nodes, as in :class:`FunctionDef`."
msgstr ""

#: ../../library/ast.rst:1833
msgid "Async and await"
msgstr ""

#: ../../library/ast.rst:1837
msgid ""
"An ``async def`` function definition. Has the same fields as "
":class:`FunctionDef`."
msgstr ""

#: ../../library/ast.rst:1843
msgid ""
"An ``await`` expression. ``value`` is what it waits for. Only valid in "
"the body of an :class:`AsyncFunctionDef`."
msgstr ""

#: ../../library/ast.rst:1876
msgid ""
"``async for`` loops and ``async with`` context managers. They have the "
"same fields as :class:`For` and :class:`With`, respectively. Only valid "
"in the body of an :class:`AsyncFunctionDef`."
msgstr ""

#: ../../library/ast.rst:1881
msgid ""
"When a string is parsed by :func:`ast.parse`, operator nodes (subclasses "
"of :class:`ast.operator`, :class:`ast.unaryop`, :class:`ast.cmpop`, "
":class:`ast.boolop` and :class:`ast.expr_context`) on the returned tree "
"will be singletons. Changes to one will be reflected in all other "
"occurrences of the same value (e.g. :class:`ast.Add`)."
msgstr ""

#: ../../library/ast.rst:1889
msgid ":mod:`ast` Helpers"
msgstr ":mod:`ast` 中的辅助工具"

#: ../../library/ast.rst:1891
msgid ""
"Apart from the node classes, the :mod:`ast` module defines these utility "
"functions and classes for traversing abstract syntax trees:"
msgstr "除了节点类， :mod:`ast` 模块里为遍历抽象语法树定义了这些工具函数和类："

#: ../../library/ast.rst:1896
msgid ""
"Parse the source into an AST node.  Equivalent to ``compile(source, "
"filename, mode, ast.PyCF_ONLY_AST)``."
msgstr ""
"把 source 解析为 AST 节点。"
"和 ``compile(source, filename, mode,ast.PyCF_ONLY_AST)`` 等价。"

#: ../../library/ast.rst:1899
msgid ""
"If ``type_comments=True`` is given, the parser is modified to check and "
"return type comments as specified by :pep:`484` and :pep:`526`. This is "
"equivalent to adding :data:`ast.PyCF_TYPE_COMMENTS` to the flags passed "
"to :func:`compile()`.  This will report syntax errors for misplaced type "
"comments.  Without this flag, type comments will be ignored, and the "
"``type_comment`` field on selected AST nodes will always be ``None``.  In"
" addition, the locations of ``# type: ignore`` comments will be returned "
"as the ``type_ignores`` attribute of :class:`Module` (otherwise it is "
"always an empty list)."
msgstr ""
"如果给定 ``type_comments=True``，解析器会被修改，"
"以检查并返回 :pep:`484` 和 :pep:`526` 所指定的类型注释。"
"这相当于将 :data:`ast.PyCF_TYPE_COMMENTS` 添加到传递给 :func:`compile()` 的标志中。"
"这将报告错误的类型注释的语法错误。"
"如果没有这个标志，类型注释将被忽略，选定的 AST 节点上的 ``type_comment`` 字段将一直是 ``None``。"
"此外，``# type: ignore`` 注释的位置将作为 :class:`Module` 的 ``type_ignores`` 属性返回（否则它总是一个空列表）。"

#: ../../library/ast.rst:1909
msgid ""
"In addition, if ``mode`` is ``'func_type'``, the input syntax is modified"
" to correspond to :pep:`484` \"signature type comments\", e.g. ``(str, "
"int) -> List[str]``."
msgstr ""
"此外，如果 ``mode`` 是 ``'func_type'``，输入语法将被修改为对应于 :pep:`484` 签名类型注释，"
"例如 ``(str, int) -> List[str]``。"

#: ../../library/ast.rst:1913
msgid ""
"Also, setting ``feature_version`` to a tuple ``(major, minor)`` will "
"attempt to parse using that Python version's grammar. Currently ``major``"
" must equal to ``3``.  For example, setting ``feature_version=(3, 4)`` "
"will allow the use of ``async`` and ``await`` as variable names.  The "
"lowest supported version is ``(3, 4)``; the highest is "
"``sys.version_info[0:2]``."
msgstr ""
"另外，将 ``feature_version`` 设置为一个元组 ``(major, minor)`` "
"将尝试使用该 Python 版本的语法进行解析。"
"目前 ``major`` 必须等于 ``3``。"
"例如，设置 ``feature_version=(3, 4)`` 将允许使用 ``async`` 和 ``await`` 作为变量名。"
"支持的最低版本是 ``(3, 4)``；最高版本是 ``sys.version_info[0:2]``。"

#: ../../library/ast.rst:1920
msgid "If source contains a null character ('\\0'), :exc:`ValueError` is raised."
msgstr "如果 source 包含一个空字符（'\\0'），:exc:`ValueError` 将被触发。"

#: ../../library/ast.rst:1923
msgid ""
"Note that successfully parsing source code into an AST object doesn't "
"guarantee that the source code provided is valid Python code that can be "
"executed as the compilation step can raise further :exc:`SyntaxError` "
"exceptions. For instance, the source ``return 42`` generates a valid AST "
"node for a return statement, but it cannot be compiled alone (it needs to"
" be inside a function node)."
msgstr ""
"注意，成功地将源代码解析成 AST 对象并不保证所提供的源代码是可以执行的有效 Python 代码，"
"因为编译步骤可能会引发进一步的 :exc:`SyntaxError` 异常。"
"例如，源码 ``return 42`` 为返回语句生成了一个有效的 AST 节点，但它不能被单独编译（它需要在一个函数节点内）。"

#: ../../library/ast.rst:1930
msgid ""
"In particular, :func:`ast.parse` won't do any scoping checks, which the "
"compilation step does."
msgstr ""
"特别是，:func:`ast.parse` 不会做任何范围检查，而编译步骤会做。"

#: ../../library/ast.rst:1934 ../../library/ast.rst:1973
msgid ""
"It is possible to crash the Python interpreter with a sufficiently "
"large/complex string due to stack depth limitations in Python's AST "
"compiler."
msgstr ""
"足够复杂或是巨大的字符串可能导致 Python 解释器的崩溃，因为 Python 的 AST 编译器是有栈深限制的。"

#: ../../library/ast.rst:1938
msgid "Added ``type_comments``, ``mode='func_type'`` and ``feature_version``."
msgstr "增加了 ``type_comments``、``mode='func_type'`` 和 ``feature_version`` 。"

#: ../../library/ast.rst:1944
msgid ""
"Unparse an :class:`ast.AST` object and generate a string with code that "
"would produce an equivalent :class:`ast.AST` object if parsed back with "
":func:`ast.parse`."
msgstr ""
"反向解析 :class:`ast.AST` 对象，并生成一个字符串，"
"如果用 :func:`ast.parse` 解析，将产生一个等价的 :class:`ast.AST` 对象的代码。"

#: ../../library/ast.rst:1949
msgid ""
"The produced code string will not necessarily be equal to the original "
"code that generated the :class:`ast.AST` object (without any compiler "
"optimizations, such as constant tuples/frozensets)."
msgstr ""
"产生的代码字符串不一定等于产生 :class:`ast.AST` 对象的原始代码（没有任何编译器优化，如常数 tuple/frozenset）。"

#: ../../library/ast.rst:1954
msgid ""
"Trying to unparse a highly complex expression would result with "
":exc:`RecursionError`."
msgstr ""
"试图解读一个高度复杂的表达式会导致 :exc:`RecursionError`。"

#: ../../library/ast.rst:1962
msgid ""
"Safely evaluate an expression node or a string containing a Python "
"literal or container display.  The string or node provided may only "
"consist of the following Python literal structures: strings, bytes, "
"numbers, tuples, lists, dicts, sets, booleans, ``None`` and ``Ellipsis``."
msgstr ""
"安全地评估一个表达式节点或一个包含 Python 字面量或容器显示的字符串。"
"提供的字符串或节点只能由以下 Python 字面量结构组成："
"字符串、字节串、数字、元组、列表、字典、集合、布尔值、``None`` 和 ``Ellipsis``。"

#: ../../library/ast.rst:1967
msgid ""
"This can be used for safely evaluating strings containing Python values "
"from untrusted sources without the need to parse the values oneself.  It "
"is not capable of evaluating arbitrarily complex expressions, for example"
" involving operators or indexing."
msgstr ""
"这可以用来安全地评估来自不受信任的来源的包含 Python 值的字符串，而不需要自己去解析这些值。"
"它不能够评估任意复杂的表达式，例如涉及运算符或索引的表达式。"

#: ../../library/ast.rst:1977
msgid ""
"It can raise :exc:`ValueError`, :exc:`TypeError`, :exc:`SyntaxError`, "
":exc:`MemoryError` and :exc:`RecursionError` depending on the malformed "
"input."
msgstr ""
"它可能引发 :exc:`ValueError`, :exc:`TypeError`, :exc:`SyntaxError`, "
":exc:`MemoryError` 和 :exc:`RecursionError` ，取决于错误的输入。"

#: ../../library/ast.rst:1981
msgid "Now allows bytes and set literals."
msgstr "目前支持字节和集合。"

#: ../../library/ast.rst:1984
msgid "Now supports creating empty sets with ``'set()'``."
msgstr "现在支持用 ``'set()'`` 创建空集合。"

#: ../../library/ast.rst:1987
msgid "For string inputs, leading spaces and tabs are now stripped."
msgstr "对于字符串输入，前面的空格和制表符现在被剥离了。"

#: ../../library/ast.rst:1993
msgid ""
"Return the docstring of the given *node* (which must be a "
":class:`FunctionDef`, :class:`AsyncFunctionDef`, :class:`ClassDef`, or "
":class:`Module` node), or ``None`` if it has no docstring. If *clean* is "
"true, clean up the docstring's indentation with :func:`inspect.cleandoc`."
msgstr ""
"返回给定 *node* 的文档字符串"
"（必须是 :class:`FunctionDef`、:class:`AsyncFunctionDef`、:class:`ClassDef` 或 :class:`Module` 节点），"
"如果没有文档字符串，则返回 ``None``。如果 *clean* 为真，则用 :func:`inspect.cleandoc` 清理该文档字符串的缩进。"

#: ../../library/ast.rst:1999
msgid ":class:`AsyncFunctionDef` is now supported."
msgstr "目前支持 :class:`AsyncFunctionDef` 。"

#: ../../library/ast.rst:2005
msgid ""
"Get source code segment of the *source* that generated *node*. If some "
"location information (:attr:`lineno`, :attr:`end_lineno`, "
":attr:`col_offset`, or :attr:`end_col_offset`) is missing, return "
"``None``."
msgstr ""
"获取生成 *node* 的 *source* 的源代码段。"
"如果某些位置信息"
"（:attr:`lineno`、:attr:`end_lineno`、:attr:`col_offset` 或 :attr:`end_col_offset` ）丢失，返回 ``None``。"

#: ../../library/ast.rst:2009
msgid ""
"If *padded* is ``True``, the first line of a multi-line statement will be"
" padded with spaces to match its original position."
msgstr ""
"如果 *padded* 是 ``True``，多行语句的第一行将被填充空格，以符合其原始位置。"

#: ../../library/ast.rst:2017
msgid ""
"When you compile a node tree with :func:`compile`, the compiler expects "
":attr:`lineno` and :attr:`col_offset` attributes for every node that "
"supports them.  This is rather tedious to fill in for generated nodes, so"
" this helper adds these attributes recursively where not already set, by "
"setting them to the values of the parent node.  It works recursively "
"starting at *node*."
msgstr ""
"当你用 :func:`compile` 编译一个节点树时，"
"编译器期望 :attr:`lineno` 和 :attr:`col_offset` 的属性对每一个节点均支持。"
"这对于生成的节点来说是相当繁琐的，所以这个帮助器在没有设置的地方递归地添加这些属性，将它们设置为父节点的值。"
"它从 *node* 开始递归工作。"

#: ../../library/ast.rst:2026
msgid ""
"Increment the line number and end line number of each node in the tree "
"starting at *node* by *n*. This is useful to \"move code\" to a different"
" location in a file."
msgstr ""
"将树中从 *node* 开始的每个节点的行号和末行号增加 *n*。这对 \"移动代码\" 到文件中的不同位置很有用。"

#: ../../library/ast.rst:2033
msgid ""
"Copy source location (:attr:`lineno`, :attr:`col_offset`, "
":attr:`end_lineno`, and :attr:`end_col_offset`) from *old_node* to "
"*new_node* if possible, and return *new_node*."
msgstr ""
"如果可能的话，从 *old_node* 复制源位置"
"（ :attr:`lineno`、:attr:`col_offset`、:attr:`end_lineno` 和 :attr:`end_col_offset` ）到 *new_node*，"
"并返回 *new_node*。"

#: ../../library/ast.rst:2040
msgid ""
"Yield a tuple of ``(fieldname, value)`` for each field in "
"``node._fields`` that is present on *node*."
msgstr ""
"为 *node* 上存在的 ``node._fields`` 中的每个字段产生一个 ``(fieldname, value)`` 的元组。"

#: ../../library/ast.rst:2046
msgid ""
"Yield all direct child nodes of *node*, that is, all fields that are "
"nodes and all items of fields that are lists of nodes."
msgstr ""
"产生 *node* 的所有直接子节点，即所有属于节点的字段和属于节点列表的字段的所有项目。"

#: ../../library/ast.rst:2052
msgid ""
"Recursively yield all descendant nodes in the tree starting at *node* "
"(including *node* itself), in no specified order.  This is useful if you "
"only want to modify nodes in place and don't care about the context."
msgstr ""
"递归产生树中从 *node* 开始的所有后代节点（包括 *node* 本身），没有指定顺序。"
"如果你只想就地修改节点，而不关心上下文，这很有用。"

#: ../../library/ast.rst:2059
msgid ""
"A node visitor base class that walks the abstract syntax tree and calls a"
" visitor function for every node found.  This function may return a value"
" which is forwarded by the :meth:`visit` method."
msgstr ""
"一个节点访问者基类，它行走在抽象的语法树上，为每个发现的节点调用一个访问者函数。"
"这个函数可以返回一个值，由 :meth:`visit` 方法转发。"

#: ../../library/ast.rst:2063
msgid ""
"This class is meant to be subclassed, with the subclass adding visitor "
"methods."
msgstr ""
"这个类是要被子类化的，子类会增加访问者方法。"

#: ../../library/ast.rst:2068
msgid ""
"Visit a node.  The default implementation calls the method called "
":samp:`self.visit_{classname}` where *classname* is the name of the node "
"class, or :meth:`generic_visit` if that method doesn't exist."
msgstr ""
"访问一个节点。"
"默认实现是调用 :samp:`self.visit_{classname}` 的方法，"
"其中 *classname* 是节点类的名称，如果该方法不存在，则调用 :meth:`generic_visit`。"

#: ../../library/ast.rst:2074
msgid "This visitor calls :meth:`visit` on all children of the node."
msgstr "这个访问者在节点的所有子节点上调用 :meth:`visit`。"

#: ../../library/ast.rst:2076
msgid ""
"Note that child nodes of nodes that have a custom visitor method won't be"
" visited unless the visitor calls :meth:`generic_visit` or visits them "
"itself."
msgstr ""
"注意，拥有自定义访客方法的节点的子节点不会被访问，除非访客调用 :meth:`generic_visit` 或自己访问它们。"

#: ../../library/ast.rst:2080
msgid ""
"Don't use the :class:`NodeVisitor` if you want to apply changes to nodes "
"during traversal.  For this a special visitor exists "
"(:class:`NodeTransformer`) that allows modifications."
msgstr ""
"如果你想在遍历过程中对节点进行修改，请不要使用 :class:`NodeVisitor`。"
"为此，存在一个特殊的访问者（:class:`NodeTransformer`），允许修改。"

#: ../../library/ast.rst:2086
msgid ""
"Methods :meth:`visit_Num`, :meth:`visit_Str`, :meth:`visit_Bytes`, "
":meth:`visit_NameConstant` and :meth:`visit_Ellipsis` are deprecated now "
"and will not be called in future Python versions.  Add the "
":meth:`visit_Constant` method to handle all constant nodes."
msgstr ""
"方法 :meth:`visit_Num`、:meth:`visit_Str`、:meth:`visit_Bytes`、:meth:`visit_NameConstant` "
"和 :meth:`visit_Ellipsis` 现在已经废弃，在未来的 Python 版本中不会被调用。"
"添加 :meth:`visit_Constant` 方法来处理所有常数节点。"

#: ../../library/ast.rst:2094
msgid ""
"A :class:`NodeVisitor` subclass that walks the abstract syntax tree and "
"allows modification of nodes."
msgstr "子类 :class:`NodeVisitor`  用于遍历抽象语法树，并允许修改节点。"

#: ../../library/ast.rst:2097
msgid ""
"The :class:`NodeTransformer` will walk the AST and use the return value "
"of the visitor methods to replace or remove the old node.  If the return "
"value of the visitor method is ``None``, the node will be removed from "
"its location, otherwise it is replaced with the return value.  The return"
" value may be the original node in which case no replacement takes place."
msgstr ""
":class:`NodeTransformer` "
"将遍历抽象语法树并使用visitor方法的返回值去替换或移除旧节点。如果visitor方法的返回值为 ``None`` , "
"则该节点将从其位置移除，否则将替换为返回值。当返回值是原始节点时，无需替换。"

#: ../../library/ast.rst:2103
msgid ""
"Here is an example transformer that rewrites all occurrences of name "
"lookups (``foo``) to ``data['foo']``::"
msgstr "如下是一个转换器示例，它将所有出现的名称 (``foo``) 重写为 ``data['foo']``:: "

#: ../../library/ast.rst:2115
msgid ""
"Keep in mind that if the node you're operating on has child nodes you "
"must either transform the child nodes yourself or call the "
":meth:`generic_visit` method for the node first."
msgstr "请记住，如果您正在操作的节点具有子节点，则必须先转换其子节点或为该节点调用 :meth:`generic_visit`  方法。"

#: ../../library/ast.rst:2119
msgid ""
"For nodes that were part of a collection of statements (that applies to "
"all statement nodes), the visitor may also return a list of nodes rather "
"than just a single node."
msgstr "对于属于语句集合（适用于所有语句节点）的节点，访问者还可以返回节点列表而不仅仅是单个节点。"

#: ../../library/ast.rst:2123
msgid ""
"If :class:`NodeTransformer` introduces new nodes (that weren't part of "
"original tree) without giving them location information (such as "
":attr:`lineno`), :func:`fix_missing_locations` should be called with the "
"new sub-tree to recalculate the location information::"
msgstr ""
"如果 :class:`NodeTransformer` 引入了新的节点（不是原来树的一部分），"
"而没有给它们位置信息（比如 :attr:`lineno`），"
"那么 :func:`fix_missing_locations` 应该与新的子树一起调用，以重新计算位置信息 ::"

#: ../../library/ast.rst:2131
msgid "Usually you use the transformer like this::"
msgstr "通常你可以像这样使用转换器 :: "

#: ../../library/ast.rst:2138
msgid ""
"Return a formatted dump of the tree in *node*.  This is mainly useful for"
" debugging purposes.  If *annotate_fields* is true (by default), the "
"returned string will show the names and the values for fields. If "
"*annotate_fields* is false, the result string will be more compact by "
"omitting unambiguous field names.  Attributes such as line numbers and "
"column offsets are not dumped by default.  If this is wanted, "
"*include_attributes* can be set to true."
msgstr ""
"返回 *node* 中树的格式化转储。这主要是为了调试的目的。"
"如果 *annotate_fields* 为 true（默认），返回的字符串将显示字段的名称和值。"
"如果 *annotate_fields* 为 false，结果字符串将通过省略不明确的字段名而变得更加紧凑。"
"默认情况下，诸如行号和列的偏移量等属性不会被转储。"
"如果希望这样，可以将 *include_attributes* 设置为 true。"

#: ../../library/ast.rst:2146
msgid ""
"If *indent* is a non-negative integer or string, then the tree will be "
"pretty-printed with that indent level.  An indent level of 0, negative, "
"or ``\"\"`` will only insert newlines.  ``None`` (the default) selects "
"the single line representation. Using a positive integer indent indents "
"that many spaces per level.  If *indent* is a string (such as "
"``\"\\t\"``), that string is used to indent each level."
msgstr ""
"如果 *indent* 是一个非负的整数或字符串，那么树就会以该缩进级别进行漂亮的打印。"
"缩进级别为 0、负数或 ``\"\"`` 将只插入新行。``None`` （默认）选择单行表示法。"
"使用正的整数缩进，每一级有那么多的空格。"
"如果 *indent* 是一个字符串（如 ``\"\\t\"``），该字符串将用于缩进每一级。"

#: ../../library/ast.rst:2153
msgid "Added the *indent* option."
msgstr "添加 *indent* 选项。"

#: ../../library/ast.rst:2160
msgid "Compiler Flags"
msgstr ""

#: ../../library/ast.rst:2162
msgid ""
"The following flags may be passed to :func:`compile` in order to change "
"effects on the compilation of a program:"
msgstr ""

#: ../../library/ast.rst:2167
msgid ""
"Enables support for top-level ``await``, ``async for``, ``async with`` "
"and async comprehensions."
msgstr ""

#: ../../library/ast.rst:2174
msgid ""
"Generates and returns an abstract syntax tree instead of returning a "
"compiled code object."
msgstr ""

#: ../../library/ast.rst:2179
msgid ""
"Enables support for :pep:`484` and :pep:`526` style type comments (``# "
"type: <type>``, ``# type: ignore <stuff>``)."
msgstr ""

#: ../../library/ast.rst:2188
msgid "Command-Line Usage"
msgstr "命令行用法"

#: ../../library/ast.rst:2192
msgid ""
"The :mod:`ast` module can be executed as a script from the command line. "
"It is as simple as:"
msgstr ""

#: ../../library/ast.rst:2199
msgid "The following options are accepted:"
msgstr "可以接受以下选项："

#: ../../library/ast.rst:2205
msgid "Show the help message and exit."
msgstr ""

#: ../../library/ast.rst:2210
msgid ""
"Specify what kind of code must be compiled, like the *mode* argument in "
":func:`parse`."
msgstr ""

#: ../../library/ast.rst:2215
msgid "Don't parse type comments."
msgstr ""

#: ../../library/ast.rst:2219
msgid "Include attributes such as line numbers and column offsets."
msgstr ""

#: ../../library/ast.rst:2224
msgid "Indentation of nodes in AST (number of spaces)."
msgstr ""

#: ../../library/ast.rst:2226
msgid ""
"If :file:`infile` is specified its contents are parsed to AST and dumped "
"to stdout.  Otherwise, the content is read from stdin."
msgstr ""

#: ../../library/ast.rst:2232
msgid ""
"`Green Tree Snakes <https://greentreesnakes.readthedocs.io/>`_, an "
"external documentation resource, has good details on working with Python "
"ASTs."
msgstr ""

#: ../../library/ast.rst:2235
msgid ""
"`ASTTokens <https://asttokens.readthedocs.io/en/latest/user-guide.html>`_"
" annotates Python ASTs with the positions of tokens and text in the "
"source code that generated them. This is helpful for tools that make "
"source code transformations."
msgstr ""

#: ../../library/ast.rst:2240
msgid ""
"`leoAst.py <http://leoeditor.com/appendices.html#leoast-py>`_ unifies the"
" token-based and parse-tree-based views of python programs by inserting "
"two-way links between tokens and ast nodes."
msgstr ""

#: ../../library/ast.rst:2244
msgid ""
"`LibCST <https://libcst.readthedocs.io/>`_ parses code as a Concrete "
"Syntax Tree that looks like an ast tree and keeps all formatting details."
" It's useful for building automated refactoring (codemod) applications "
"and linters."
msgstr ""

#: ../../library/ast.rst:2249
msgid ""
"`Parso <https://parso.readthedocs.io>`_ is a Python parser that supports "
"error recovery and round-trip parsing for different Python versions (in "
"multiple Python versions). Parso is also able to list multiple syntax "
"errors in your python file."
msgstr ""

#~ msgid ""
#~ "``body`` contains a list of nodes "
#~ "to execute if the pattern matches "
#~ "and the result of evaluating the "
#~ "guard expression is truthy."
#~ msgstr ""

