# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2021, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
# Translators:
# cissoid <yangtukun1412@gmail.com>, 2021
# Alpha Du <alphanow@gmail.com>, 2021
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-02-23 14:07+0800\n"
"PO-Revision-Date: 2021-06-28 00:54+0000\n"
"Last-Translator: Alpha Du <alphanow@gmail.com>, 2021\n"
"Language: zh_CN\n"
"Language-Team: Chinese (China) (https://www.transifex.com/python-"
"doc/teams/5390/zh_CN/)\n"
"Plural-Forms: nplurals=1; plural=0\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../library/__main__.rst:2
#, fuzzy
msgid ":mod:`__main__` --- Top-level code environment"
msgstr ":mod:`__main__` --- 顶层脚本环境"

#: ../../library/__main__.rst:10
msgid ""
"In Python, the special name ``__main__`` is used for two important "
"constructs:"
msgstr "在 Python 中，特殊名称 ``__main__`` 用于两个重要的结构："

#: ../../library/__main__.rst:12
msgid ""
"the name of the top-level environment of the program, which can be "
"checked using the ``__name__ == '__main__'`` expression; and"
msgstr "程序顶层环境的名称，可以用 ``__name__ == '__main__'`` 表达式来检查；以及"

#: ../../library/__main__.rst:14
msgid "the ``__main__.py`` file in Python packages."
msgstr "Python 软件包中的 ``__main__.py`` 文件。"

#: ../../library/__main__.rst:16
msgid ""
"Both of these mechanisms are related to Python modules; how users "
"interact with them and how they interact with each other.  They are "
"explained in detail below.  If you're new to Python modules, see the "
"tutorial section :ref:`tut-modules` for an introduction."
msgstr ""
"这两种机制都与 Python 模块有关；用户如何与它们交互以及它们之间如何交互。下面对此进行了详细的解释。如果你是 Python "
"模块的新手，请参阅教程部分 :ref:`tut-modules` 的介绍。"

#: ../../library/__main__.rst:25
msgid "``__name__ == '__main__'``"
msgstr ""

#: ../../library/__main__.rst:27
msgid ""
"When a Python module or package is imported, ``__name__`` is set to the "
"module's name.  Usually, this is the name of the Python file itself "
"without the ``.py`` extension::"
msgstr ""
"当一个 Python 模块或包被导入时，``__name__`` 被设置为模块的名称。通常，这是 Python 文件本身的名称，没有 "
"``.py`` 扩展名 ::"

#: ../../library/__main__.rst:35
msgid ""
"If the file is part of a package, ``__name__`` will also include the "
"parent package's path::"
msgstr "如果该文件是一个包的一部分，``__name__`` 也将包括父包的路径 ::"

#: ../../library/__main__.rst:42
msgid ""
"However, if the module is executed in the top-level code environment, its"
" ``__name__`` is set to the string ``'__main__'``."
msgstr "然而，如果该模块在顶层代码环境中执行，它的 ``__name__`` 被设置为字符串 ``'__main__'``。"

#: ../../library/__main__.rst:46
msgid "What is the \"top-level code environment\"?"
msgstr "什么是 \"顶层代码环境\"？"

#: ../../library/__main__.rst:48
msgid ""
"``__main__`` is the name of the environment where top-level code is run. "
"\"Top-level code\" is the first user-specified Python module that starts "
"running. It's \"top-level\" because it imports all other modules that the"
" program needs. Sometimes \"top-level code\" is called an *entry point* "
"to the application."
msgstr ""
"``__main__`` 是运行顶层代码的环境名称。\"顶层代码\" 是第一个开始运行的用户指定的 Python 模块。它是 \"顶层代码\" "
"因为它导入了程序需要的所有其它模块。有时，\"顶层代码\" 被称为应用程序的 *入口点*。"

#: ../../library/__main__.rst:53
msgid "The top-level code environment can be:"
msgstr "顶层的代码环境可以是："

#: ../../library/__main__.rst:55
msgid "the scope of an interactive prompt::"
msgstr "交互提示的范围 ::"

#: ../../library/__main__.rst:60
msgid "the Python module passed to the Python interpreter as a file argument:"
msgstr "作为文件参数传递给 Python 解释器的 Python 模块："

#: ../../library/__main__.rst:67
msgid ""
"the Python module or package passed to the Python interpreter with the "
":option:`-m` argument:"
msgstr "通过 :option:`-m` 参数传递给 Python 解释器的 Python 模块或包："

#: ../../library/__main__.rst:75
msgid "Python code read by the Python interpreter from standard input:"
msgstr "Python 解释器从标准输入读取的 Python 代码："

#: ../../library/__main__.rst:86
msgid ""
"Python code passed to the Python interpreter with the :option:`-c` "
"argument:"
msgstr "用 :option:`-c` 参数传递给 Python 解释器的 Python 代码："

#: ../../library/__main__.rst:97
msgid ""
"In each of these situations, the top-level module's ``__name__`` is set "
"to ``'__main__'``."
msgstr "在每一种情况下，顶层模块的 ``__name__`` 被设置为 ``'__main__'``。"

#: ../../library/__main__.rst:100
msgid ""
"As a result, a module can discover whether or not it is running in the "
"top-level environment by checking its own ``__name__``, which allows a "
"common idiom for conditionally executing code when the module is not "
"initialized from an import statement::"
msgstr ""
"因此，一个模块可以通过检查它自己的 ``__name__`` "
"来得知是否在顶层环境中运行，这就允许在模块没有从导入语句中初始化时，有条件地执行代码的常见习语 ::"

#: ../../library/__main__.rst:111
msgid ""
"For a more detailed look at how ``__name__`` is set in all situations, "
"see the tutorial section :ref:`tut-modules`."
msgstr "关于在所有情况下如何设置 ``__name__`` 的问题，请看教程部分 :ref:`tut-modules`。"

#: ../../library/__main__.rst:116 ../../library/__main__.rst:239
msgid "Idiomatic Usage"
msgstr "习语用法"

#: ../../library/__main__.rst:118
msgid ""
"Some modules contain code that is intended for script use only, like "
"parsing command-line arguments or fetching data from standard input.  If "
"a module like this was imported from a different module, for example to "
"unit test it, the script code would unintentionally execute as well."
msgstr "有些模块包含了仅供脚本使用的代码，比如解析命令行参数或从标准输入获取数据。如果像这样的模块被从不同的模块中导入，例如为了单元测试，脚本代码也会无意中执行。"

#: ../../library/__main__.rst:123
msgid ""
"This is where using the ``if __name__ == '__main__'`` code block comes in"
" handy. Code within this block won't run unless the module is executed in"
" the top-level environment."
msgstr "这就是使用 ``if __name__ == '__main__'`` 代码块的用武之地。除非模块在顶层环境中被执行，否则该块中的代码不会运行。"

#: ../../library/__main__.rst:127
msgid ""
"Putting as few statements as possible in the block below ``if __name___ "
"== '__main__'`` can improve code clarity and correctness. Most often, a "
"function named ``main`` encapsulates the program's primary behavior::"
msgstr ""
"在 ``if __name___ == '__main__'`` 下面的块中放入尽可能少的语句可以提高代码的清晰度和正确性。大多数情况下，一个名为"
" ``main`` 的函数封装了程序的主要行为 ::"

#: ../../library/__main__.rst:151
msgid ""
"Note that if the module didn't encapsulate code inside the ``main`` "
"function but instead put it directly within the ``if __name__ == "
"'__main__'`` block, the ``phrase`` variable would be global to the entire"
" module.  This is error-prone as other functions within the module could "
"be unintentionally using the global variable instead of a local name.  A "
"``main`` function solves this problem."
msgstr ""
"注意，如果模块没有在 ``main`` 函数内封装代码，而是直接放在 ``if __name__ == '__main__'`` "
"块内，``phrase`` 变量将对整个模块是全局的。这很容易出错，因为模块中的其他函数可能会无意中使用全局变量而不是局部名称。一个 "
"``main`` 函数解决了这个问题。"

#: ../../library/__main__.rst:158
msgid ""
"Using a ``main`` function has the added benefit of the ``echo`` function "
"itself being isolated and importable elsewhere. When ``echo.py`` is "
"imported, the ``echo`` and ``main`` functions will be defined, but "
"neither of them will be called, because ``__name__ != '__main__'``."
msgstr ""
"使用 ``main`` 函数有一个额外的好处，就是 ``echo`` 函数本身是孤立的，可以在其他地方导入。当 ``echo.py`` "
"被导入时，``echo`` 和 ``main`` 函数将被定义，但它们都不会被调用，因为 ``__name__ != '__main__'``。"

#: ../../library/__main__.rst:165
msgid "Packaging Considerations"
msgstr "包装方面的考虑"

#: ../../library/__main__.rst:167
msgid ""
"``main`` functions are often used to create command-line tools by "
"specifying them as entry points for console scripts.  When this is done, "
"`pip <https://pip.pypa.io/>`_ inserts the function call into a template "
"script, where the return value of ``main`` is passed into "
":func:`sys.exit`. For example::"
msgstr ""

#: ../../library/__main__.rst:175
msgid ""
"Since the call to ``main`` is wrapped in :func:`sys.exit`, the "
"expectation is that your function will return some value acceptable as an"
" input to :func:`sys.exit`; typically, an integer or ``None`` (which is "
"implicitly returned if your function does not have a return statement)."
msgstr ""

#: ../../library/__main__.rst:180
msgid ""
"By proactively following this convention ourselves, our module will have "
"the same behavior when run directly (i.e. ``python3 echo.py``) as it will"
" have if we later package it as a console script entry-point in a pip-"
"installable package."
msgstr ""

#: ../../library/__main__.rst:185
msgid ""
"In particular, be careful about returning strings from your ``main`` "
"function. :func:`sys.exit` will interpret a string argument as a failure "
"message, so your program will have an exit code of ``1``, indicating "
"failure, and the string will be written to :data:`sys.stderr`.  The "
"``echo.py`` example from earlier exemplifies using the "
"``sys.exit(main())`` convention."
msgstr ""

#: ../../library/__main__.rst:193
msgid ""
"`Python Packaging User Guide <https://packaging.python.org/>`_ contains a"
" collection of tutorials and references on how to distribute and install "
"Python packages with modern tools."
msgstr ""

#: ../../library/__main__.rst:199
msgid "``__main__.py`` in Python Packages"
msgstr ""

#: ../../library/__main__.rst:201
msgid ""
"If you are not familiar with Python packages, see section :ref:`tut-"
"packages` of the tutorial.  Most commonly, the ``__main__.py`` file is "
"used to provide a command-line interface for a package. Consider the "
"following hypothetical package, \"bandclass\":"
msgstr ""

#: ../../library/__main__.rst:213
msgid ""
"``__main__.py`` will be executed when the package itself is invoked "
"directly from the command line using the :option:`-m` flag. For example:"
msgstr ""

#: ../../library/__main__.rst:220
msgid ""
"This command will cause ``__main__.py`` to run. How you utilize this "
"mechanism will depend on the nature of the package you are writing, but "
"in this hypothetical case, it might make sense to allow the teacher to "
"search for students::"
msgstr ""

#: ../../library/__main__.rst:233
msgid ""
"Note that ``from .student import search_students`` is an example of a "
"relative import.  This import style can be used when referencing modules "
"within a package.  For more details, see :ref:`intra-package-references` "
"in the :ref:`tut-modules` section of the tutorial."
msgstr ""

#: ../../library/__main__.rst:241
msgid ""
"The contents of ``__main__.py`` typically isn't fenced with ``if __name__"
" == '__main__'`` blocks.  Instead, those files are kept short, functions "
"to execute from other modules.  Those other modules can then be easily "
"unit-tested and are properly reusable."
msgstr ""

#: ../../library/__main__.rst:246
msgid ""
"If used, an ``if __name__ == '__main__'`` block will still work as "
"expected for a ``__main__.py`` file within a package, because its "
"``__name__`` attribute will include the package's path if imported::"
msgstr ""

#: ../../library/__main__.rst:254
msgid ""
"This won't work for ``__main__.py`` files in the root directory of a .zip"
" file though.  Hence, for consistency, minimal ``__main__.py`` like the "
":mod:`venv` one mentioned below are preferred."
msgstr ""

#: ../../library/__main__.rst:260
msgid ""
"See :mod:`venv` for an example of a package with a minimal "
"``__main__.py`` in the standard library. It doesn't contain a ``if "
"__name__ == '__main__'`` block. You can invoke it with ``python3 -m venv "
"[directory]``."
msgstr ""

#: ../../library/__main__.rst:264
msgid ""
"See :mod:`runpy` for more details on the :option:`-m` flag to the "
"interpreter executable."
msgstr ""

#: ../../library/__main__.rst:267
msgid ""
"See :mod:`zipapp` for how to run applications packaged as *.zip* files. "
"In this case Python looks for a ``__main__.py`` file in the root "
"directory of the archive."
msgstr ""

#: ../../library/__main__.rst:274
msgid "``import __main__``"
msgstr ""

#: ../../library/__main__.rst:276
msgid ""
"Regardless of which module a Python program was started with, other "
"modules running within that same program can import the top-level "
"environment's scope (:term:`namespace`) by importing the ``__main__`` "
"module.  This doesn't import a ``__main__.py`` file but rather whichever "
"module that received the special name ``'__main__'``."
msgstr ""

#: ../../library/__main__.rst:282
msgid "Here is an example module that consumes the ``__main__`` namespace::"
msgstr ""

#: ../../library/__main__.rst:300
msgid "Example usage of this module could be as follows::"
msgstr ""

#: ../../library/__main__.rst:319
msgid "Now, if we started our program, the result would look like this:"
msgstr ""

#: ../../library/__main__.rst:326
msgid ""
"The exit code of the program would be 1, indicating an error. "
"Uncommenting the line with ``my_name = \"Dinsdale\"`` fixes the program "
"and now it exits with status code 0, indicating success:"
msgstr ""

#: ../../library/__main__.rst:335
msgid ""
"Note that importing ``__main__`` doesn't cause any issues with "
"unintentionally running top-level code meant for script use which is put "
"in the ``if __name__ == \"__main__\"`` block of the ``start`` module. Why"
" does this work?"
msgstr ""

#: ../../library/__main__.rst:339
msgid ""
"Python inserts an empty ``__main__`` module in :attr:`sys.modules` at "
"interpreter startup, and populates it by running top-level code. In our "
"example this is the ``start`` module which runs line by line and imports "
"``namely``. In turn, ``namely`` imports ``__main__`` (which is really "
"``start``). That's an import cycle! Fortunately, since the partially "
"populated ``__main__`` module is present in :attr:`sys.modules`, Python "
"passes that to ``namely``. See :ref:`Special considerations for __main__ "
"<import-dunder-main>` in the import system's reference for details on how"
" this works."
msgstr ""

#: ../../library/__main__.rst:348
msgid ""
"The Python REPL is another example of a \"top-level environment\", so "
"anything defined in the REPL becomes part of the ``__main__`` scope::"
msgstr ""

#: ../../library/__main__.rst:364
msgid ""
"Note that in this case the ``__main__`` scope doesn't contain a "
"``__file__`` attribute as it's interactive."
msgstr ""

#: ../../library/__main__.rst:367
msgid ""
"The ``__main__`` scope is used in the implementation of :mod:`pdb` and "
":mod:`rlcompleter`."
msgstr ""

#~ msgid ""
#~ "``'__main__'`` is the name of the "
#~ "scope in which top-level code "
#~ "executes. A module's __name__ is set "
#~ "equal to ``'__main__'`` when read from"
#~ " standard input, a script, or from"
#~ " an interactive prompt."
#~ msgstr ""
#~ "``'__main__'`` 是顶层代码执行的作用域的名称。模块的 __name__ "
#~ "在通过标准输入、脚本文件或是交互式命令读入的时候会等于 ``'__main__'``。"

#~ msgid ""
#~ "For a package, the same effect can"
#~ " be achieved by including a "
#~ "``__main__.py`` module, the contents of "
#~ "which will be executed when the "
#~ "module is run with ``-m``."
#~ msgstr "对软件包来说，通过加入 ``__main__.py`` 模块可以达到同样的效果，当使用 ``-m`` 运行模块时，其中的代码会被执行。"

#~ msgid ""
#~ "This won't work for ``__main__.py`` "
#~ "files in the root directory of a"
#~ " .zip file though.  Hence, for "
#~ "consistency, minimal ``__main__.py`` like the"
#~ " :mod:`venv` one mentioned above are "
#~ "preferred."
#~ msgstr ""

